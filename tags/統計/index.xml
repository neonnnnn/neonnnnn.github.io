<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>統計 on 積んでるゲームのサントラを聴く</title><link>https://neonnnnn.github.io/tags/%E7%B5%B1%E8%A8%88/</link><description>Recent content in 統計 on 積んでるゲームのサントラを聴く</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><copyright>Kyohei Atarashi</copyright><lastBuildDate>Sat, 05 Feb 2022 04:40:50 +0900</lastBuildDate><atom:link href="https://neonnnnn.github.io/tags/%E7%B5%B1%E8%A8%88/index.xml" rel="self" type="application/rss+xml"/><item><title>被覆数と充填数の簡単な応用</title><link>https://neonnnnn.github.io/posts/covering-packing-easy-application/</link><pubDate>Sat, 05 Feb 2022 04:40:50 +0900</pubDate><guid>https://neonnnnn.github.io/posts/covering-packing-easy-application/</guid><description>はじめに 前回の記事から悠久の時が経ってしまった……（一週間以内に更新する予定だったのですが、うっかりダンガンロンパに手を出してグダグダになってしまった）。前回の記事ではConvering Number（被覆数）とPacking Number（充填数）を紹介しました。今回の記事では被覆数と充填数の簡単な応用として、
誤り訂正符号（[1]の4.3より） 0階の最適化アルゴリズム ランダムフーリエ特徴[2] の誤差の評価方法を紹介します。
誤り訂正符号の誤差の評価 問題設定・問題意識 舞園さんは長さ$k$の文字列を苗木くんに送りたいです。このとき、攻撃者モノクマによって、送信したメッセージのうち最大で$r$個の文字が書き換えられてしまい、苗木くんは書き換えられたメッセージを受け取ります。例えば、舞園さんは「エスパーですから」という文字列を送るも（$k=8$）、モノクマの悪質なイタズラによって、苗木くんが受け取るメッセージは「アイドルですから」になってしまう、といったものです（$k=4$）。
舞園さんはどのようにすれば正しいメッセージを苗木くんに送ることができるでしょうか？一般的な方法は冗長性をもたせることです。例えば、Majority (logic) Decodingという方法では、舞園さんは元のメッセージを$2r+1$回繰り返したメッセージを送り、苗木くんは繰り返されたメッセージに対して多数決を取ることによって正しい文字列を得ます。上の例にMajority Decodingを適用してみましょう。舞園さんは「エスパーですから」を$2r+1=9$回繰り返した「エスパーですからエスパーですからエスパーですからエスパーですからエスパーですからエスパーですからエスパーですからエスパーですからエスパーですから」という文字列を送ります。そうすると、どのように$r=4$個の文字を変更しようとも、$9$個の（長さ$k=8$の）文字列の中で最も出現頻度が多いのは「エスパーですから」になり、苗木くんは正しいメッセージを受け取ることができます。
Majority Decodingはシンプルでわかりやすいですが、直感的にはなんとも効率が悪そうに思えます。 もっと良い方法はないのでしょうか？
誤り訂正符号と充填数の関係 上の例では日本語の文字列を考えましたが、ここでは0/1の二値の文字列を考えます。まず、誤り訂正符号の定義を以下に示します。
定義4.3.3（誤り訂正符号） ある（固定された）正の整数$k, n, r$が与えられる。２つの写像 \begin{align} E: \{0, 1\}^k \to \{0, 1\}^n \quad \text{and} \quad E: \{0, 1\}^n \to \{0, 1\}^k \end{align} は、任意の$x \in \{0, 1\}^k$と、$E(x)$と最大で$r$個の文字が異なる任意の文字列$y$について、$D(y)=x$が成り立つとき、($r$個の誤りを訂正できる)符号写像、復号写像という。$E$を誤り訂正符号、$E$の像$E(\{0, 1\}^k)$を符号表（codebook）といい、符号表の各要素（すなわち、$E(x)$）を符号語という。 $k, n, r$はそれぞれ「送りたい文字列の長さ」「誤りを考慮して送る文字の長さ」「発生する最大の誤りの数」に対応します。$n$は小さければ小さいほど、効率の良い方法ということになります。前述のMajority decodingでは$n=k(2r+1)$でしたが、これよりも効率の良い方法が存在するのかが気になります。充填数を使うことで、より効率の良い方法が存在することを主張できます。
補題4.3.4 正の数$k, r$に対して、$n$が \begin{align} \log \mathcal{P}(\{0, 1\}^n, d_H, 2r) \ge k \end{align} を満たすとする。このとき、$k$ビットの文字列を$n$ビットの文字列に符号化し、$r$個の誤りを訂正することのできる、誤り訂正符号が存在する。 証明 $\mathcal{N} \subseteq \{0, 1\}^n$を、$n$次元ハミングキューブ$(\{0, 1\}^n, d_H)$のある$2r$-separatedとする。 定義より、$\mathcal{N}$の各要素$x, y \in \mathcal{N}$はハミング距離が$2r$より大きい、すなわち、互いに$2r+1$個以上の文字が異なっている。したがって、$x \in \mathcal{N}$は、最大で$r$個の文字が変わり$x' \in \{0, 1\}^n$になったとしても、$\mathcal{N}$の中で最もハミング距離の近い要素は$x$のままである： \begin{align} x = \underset{y \in \mathcal{N}}{\mathrm{argmin}} \ d_{H}(y, x'), \ \forall x'\in \{0,1\}^n \ \text{s.</description></item><item><title>被覆数・充填数</title><link>https://neonnnnn.github.io/posts/covering-packing/</link><pubDate>Sun, 07 Nov 2021 00:46:02 +0900</pubDate><guid>https://neonnnnn.github.io/posts/covering-packing/</guid><description>はじめに 応用数学的な分野でしばしば用いられる道具として、Covering Number（被覆数）とPacking Number（充填数）と呼ばれるものがあります。ちょっと嘘があるのですが、一言で表現すると、 距離空間上の集合に対して、被覆数は（ある指定された半径の）球を何個持ってこれば覆うことができるか、充填数は球を何個詰め込むことができるか、を表します。前回の記事の0階の最適化アルゴリズムの解析のユークリッドノルムへの拡張が、充填数の簡単な応用例になっているなと思い、記憶の呼び起こしも含めて簡単にまとめてみることにしました。思いの外長くなってしまったので（体感）、実際に応用してみるのは次回にして、今回は被覆数・充填数の導入にとどめます（記事数稼ぎ）。
文献[1]が簡潔にまとめてくれているので、表記、ステートメントおよびその番号についてはそちらを参照して書くことにします（ところどころ簡略化しますが）。
被覆数と充填数 前述の通り、距離空間上の集合と$\varepsilon&amp;gt;0$に対して、被覆数はその集合を覆うために必要な半径$\varepsilon$の球の個数です。集合を球で覆っているときの、球の中心の集合を$\varepsilon$-netと呼びます。フォーマルに定義すると以下のようになります。
定義 4.2.1（$\varepsilon$-net） $(T, d)$を距離空間とする。$T$の部分集合$K \subset T$とある正の実数$\varepsilon &amp;gt; 0$を考える。$K$の部分集合$\mathcal{N} \subset K$は、$K$の各点が$\mathcal{N}$のある点と距離が$\varepsilon$以下であるとき、すなわち、 \begin{align} \forall x \in K\ \exists x_0 \in \mathcal{N}: \ d(x, x_0) \le \varepsilon \end{align} であるとき、$K$の$\varepsilon$-netであるという。 定義 4.2.2（被覆数） $K$の$\varepsilon$-netの最小の濃度を$K$の（$\varepsilon$-）被覆数と呼び、$\mathcal{N}(K, d, \varepsilon)$と書く。 被覆数をもう少しフォーマルに書くと、以下のようになります： \begin{align} \mathcal{N}(K, d, \varepsilon) = \min \{|X| : X \subseteq K, \ \text{$X$は$K$の$\varepsilon$-net} \}. \end{align}
さて、$K$は任意の$\varepsilon$に対してその被覆数が有限であるときかつそのときに限りプレコンパクト（$K$の閉包がコンパクト）です。解析学・集合と位相では、コンパクトであること（とそこから導かれる良い性質）だけを気にして、実際に何個の開集合で覆うことができるかということはあまり考えていなかった気がします。具体的に個数を考えるところがなんとなく応用数学っぽいなと感じます（素人並の感想）。
次に、同様にして充填数を定義します。被覆数は覆うために必要な球の最小の個数でしたが、充填数は詰め込むことのできる半径$\varepsilon/2$の球の最大の個数です（後述しますが、これはちょっと嘘です）。球の中心の集合を$\varepsilon$-separatedと言います。
定義4.2.4（$\varepsilon$-separatedと充填数） 距離空間$(T, d)$の部分集合$\mathcal{N}$は、すべての相異なる二点$x, y \in \mathcal{N}$について$d(x, y) &amp;gt; \varepsilon$であるとき、$\varepsilon$-separatedであるという。また、$T$の部分集合$K \subset T$の$\varepsilon$-separatedの最大の濃度を$K$の（$\varepsilon$-）充填数といい、$\mathcal{P}(K, d, \varepsilon)$と書く。 ステートメントを素直に訳すならば、「互いに$\varepsilon$以上離れるように配置した点の集合」が$\varepsilon$-separatedで、充填数はその最大濃度です。</description></item></channel></rss>