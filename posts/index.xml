<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 積んでるゲームのサントラを聴く</title><link>https://neonnnnn.github.io/posts/</link><description>Recent content in Posts on 積んでるゲームのサントラを聴く</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><copyright>Kyohei Atarashi</copyright><lastBuildDate>Mon, 25 Oct 2021 01:56:30 +0900</lastBuildDate><atom:link href="https://neonnnnn.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>0階/1階最適化アルゴリズムの反復数の下界</title><link>https://neonnnnn.github.io/posts/nesterov-book-lower-bound/</link><pubDate>Mon, 25 Oct 2021 01:56:30 +0900</pubDate><guid>https://neonnnnn.github.io/posts/nesterov-book-lower-bound/</guid><description>はじめに 様々な最適化問題に対して、それを解くための様々な最適化アルゴリズムが提案されています。 最適化問題の解きやすさ・最適化アルゴリズムの良し悪しの議論の際に、収束レート、すなわち、$\varepsilon$-近似解を得るために必要な反復数のオーダーというものを考えることがあります（あるいは、結局は同じことですが、反復数に対する精度$\varepsilon$のオーダー）。 Nesterov先生の本、Lectures on Convex Optimizationに、0階/1階の最適化アルゴリズムという比較的広いクラスの最適化アルゴリズムの反復数の下界の証明があり、そういえばステートメントは見たことがあったが証明までは見たことがなかったと思い、自分の言葉でややカジュアルに整理してみます（外せる・緩めることのできる仮定などもありますが、とりあえずはそのままで）。
問題設定 問題設定 何らかの連続性を持つ関数$f:\mathbb{R}^n \to \mathbb{R}$に対して、以下の最適化問題を考えます： \begin{align} \min_{x \in C \subseteq \mathbb{R}^n } f(x). \end{align} また、「連続最適化問題を解く」は「$\varepsilon$-近似解（$\varepsilon&amp;gt;0$）を得る」こと、すなわち、 $$f(\bar{x}) - f(x^*) &amp;lt; \varepsilon, \ \text{where} \ x^* = \underset{x\in C} {\mathrm{argmin}}f(x)$$ を満たす$\bar{x} \in C$を得ること、と定義します。 この$\bar{x}$を得るための反復数の下界、すなわち、最悪ケースでどの程度の反復数が必要になるのか、ということについて考えます。
考える最適化アルゴリズム 様々な最適化アルゴリズムが存在しますが、その多くは反復法と呼ばれる枠組みに入ります。 反復法は、ひどく一般化して書くと、以下のような手順で最適化を行います：
初期解$x_0$と精度$\varepsilon$が与えられる。$k=0$とする。 現在の解$x_k$でオラクルを呼ぶ。オラクルは最適化問題に関する何らかの情報を返す。情報の集合にオラクルから得られた情報を追加する。 情報の集合と、アルゴリズムが定める規則に基づいて、次の解$x_{k+1}$を生成する。 収束条件のチェックをする。$f(x_{k+1}) - f(x^*) &amp;lt; \varepsilon$ならば$\bar{x}:=x_{k+1}$として$\bar{x}$を返す。さもなければ、$k \leftarrow k+1$として、2に戻る。 「オラクルからどのような情報を得るか」「どのように更新するか」が、アルゴリズムの設計において重要になってきます（前者は、設計というよりも問題設定・前提、と言ったほうが正確な気もしますが）。 ここでは、以下の二種類のオラクルについて考えます。
0階オラクル：関数の値$f(x_k)$を返す。 1階オラクル：関数の値$f(x_k)$とその勾配$\nabla f(x_k)$を返す。 0階オラクルを用いる場合（しか用いることができない場合）は、いわゆるブラックボックス関数の最適化問題になるかと思います。 また、1階オラクルを用いる手法はいわゆる勾配ベースの方法になります。 0階オラクルを用いる最適化アルゴリズムを0階の最適化アルゴリズム、1階のオラクルを用いる最適化アルゴリズムを1階の最適化アルゴリズムと呼ぶことにします。
0階の最適化アルゴリズムの場合の下界 最適化問題に対する仮定 実行可能領域として、以下を考えます： \begin{align} B_n = \{x \in \mathbb{R}^n \mid 0 \le x^{(i)} \le 1, i=1,\ldots, n\}.</description></item><item><title>LaTeX Test</title><link>https://neonnnnn.github.io/posts/latex-test/</link><pubDate>Sat, 16 Oct 2021 03:00:00 +0900</pubDate><guid>https://neonnnnn.github.io/posts/latex-test/</guid><description>はじめに Github Pagesを用いて、テックっぽいことや機械学習とその周辺分野に関するアウトプットを行うことにした。 Github Pagesを選んだのは、自由度と手軽さのバランスが良さそうだったからなわけだが、とはいえ自分でゴリゴリCSSやらHTMLやらを書くのは気乗りしない（しセンスもない）ので、Hugoを使って整備をすることにした。 HugoはGo言語で書かれた静的サイトジェネレータで、高速なのが売りっぽい。 テーマも様々提供されていて、どれもこれも質が高い。 パーッと眺めてみて、なんとなくCactusというテーマが気に入りそれを利用することにした。 Github Pages及びHugoの導入自体は非常に簡単で、公式のquick-startとhosting-on-githubに従えば良い。
MathJaxの導入 記事を書くにあたって、数式の記載は避けられない。 このような場合、MathJaxが定番だと思っていたが、ちょっと調べて見た感じだと、どうやらKaTeXというのが最近は良いらしい。 が、CactusでMathJaxが標準でサポートされているので、今回はそのままMathJaxを使うことにする。 速度に不満が出てきたり、Hugoに興味がでた場合にKaTeXへの以降を考えたい。
CactusでのMathJaxの利用は簡単で、front matterにmathjax: trueと記載すれば良い。 以下、簡単なテスト。
inline数式 $で囲めば良い。 $a$, $\boldsymbol{a}$, $\lVert \boldsymbol{x}^\top \rVert^2$ $\sum_{i=1}^N x_i$
別行立て $$で囲めば良い。 $$ \exp (a_i) + \log \left [\frac{b_i}{c_i} + d_i \right] + \lambda $$
alignも使える。改行はバックスラッシュ6つで行う。 \begin{align} \log abc &amp;amp;= \log ab + \log c \\\ &amp;amp;=\log a + \log b + \log c \end{align} 上の数式は以下に対応する。
\begin{align} \log abc &amp;amp;= \log ab + \log c \\\\\\ &amp;amp;=\log a + \log b + \log c \end{align}</description></item><item><title>Code Block Test</title><link>https://neonnnnn.github.io/posts/code-block-test/</link><pubDate>Sun, 27 Jun 2021 09:00:00 +0000</pubDate><guid>https://neonnnnn.github.io/posts/code-block-test/</guid><description>String
Using indents:
text text text Fenced code block:
text text &amp;lt;tag&amp;gt; Fenced code block with language (lineNumbersInTable = false):
1// JavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJava 2public final class String 3 implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence 4{ 5 /** The value is used for character storage. */ 6 private final char value[]; 7 8 /** The offset is the first index of the storage that is used. */ 9 private final int offset; 10 11 /** The count is the number of characters in the String.</description></item></channel></rss>