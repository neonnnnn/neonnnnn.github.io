<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>積んでるゲームのサントラを聴く</title><link>https://neonnnnn.github.io/</link><description>Recent content on 積んでるゲームのサントラを聴く</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><copyright>Kyohei Atarashi</copyright><lastBuildDate>Sun, 07 Nov 2021 00:46:02 +0900</lastBuildDate><atom:link href="https://neonnnnn.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>被覆数・充填数</title><link>https://neonnnnn.github.io/posts/covering-packing/</link><pubDate>Sun, 07 Nov 2021 00:46:02 +0900</pubDate><guid>https://neonnnnn.github.io/posts/covering-packing/</guid><description>はじめに 応用数学的な分野でしばしば用いられる道具として、Covering Number（被覆数）とPacking Number（充填数）と呼ばれるものがあります。ちょっと嘘があるのですが、一言で表現すると、 距離空間上の集合に対して、被覆数は（ある指定された半径の）球を何個持ってこれば覆うことができるか、充填数は球を何個詰め込むことができるか、を表します。前回の記事の0階の最適化アルゴリズムの解析のユークリッドノルムへの拡張が、充填数の簡単な応用例になっているなと思い、記憶の呼び起こしも含めて簡単にまとめてみることにしました。思いの外長くなってしまったので（体感）、実際に応用してみるのは次回にして、今回は被覆数・充填数の導入にとどめます（記事数稼ぎ）。
文献[1]が簡潔にまとめてくれているので、表記、ステートメントおよびその番号についてはそちらを参照して書くことにします（ところどころ簡略化しますが）。
被覆数と充填数 前述の通り、距離空間上の集合と$\varepsilon&amp;gt;0$に対して、被覆数はその集合を覆うために必要な半径$\varepsilon$の球の個数です。集合を球で覆っているときの、球の中心の集合を$\varepsilon$-netと呼びます。フォーマルに定義すると以下のようになります。
定義 4.2.1（$\varepsilon$-net） $(T, d)$を距離空間とする。$T$の部分集合$K \subset T$とある正の実数$\varepsilon &amp;gt; 0$を考える。$K$の部分集合$\mathcal{N} \subset K$は、$K$の各点が$\mathcal{N}$のある点と距離が$\varepsilon$以下であるとき、すなわち、 \begin{align} \forall x \in K\ \exists x_0 \in \mathcal{N}: \ d(x, x_0) \le \varepsilon \end{align} であるとき、$K$の$\varepsilon$-netであるという。 定義 4.2.2（被覆数） $K$の$\varepsilon$-netの最小の濃度を$K$の（$\varepsilon$-）被覆数と呼び、$\mathcal{N}(K, d, \varepsilon)$と書く。 被覆数をもう少しフォーマルに書くと、以下のようになります： \begin{align} \mathcal{N}(K, d, \varepsilon) = \min \{|X| : X \subseteq K, \ \text{$X$は$K$の$\varepsilon$-net} \}. \end{align}
さて、$K$は任意の$\varepsilon$に対してその被覆数が有限であるときかつそのときに限りプレコンパクト（$K$の閉包がコンパクト）です。解析学・集合と位相では、コンパクトであること（とそこから導かれる良い性質）だけを気にして、実際に何個の開集合で覆うことができるかということはあまり考えていなかった気がします。具体的に個数を考えるところがなんとなく応用数学っぽいなと感じます（素人並の感想）。
次に、同様にして充填数を定義します。被覆数は覆うために必要な球の最小の個数でしたが、充填数は詰め込むことのできる半径$\varepsilon/2$の球の最大の個数です（後述しますが、これはちょっと嘘です）。球の中心の集合を$\varepsilon$-separatedと言います。
定義4.2.4（$\varepsilon$-separatedと充填数） 距離空間$(T, d)$の部分集合$\mathcal{N}$は、すべての相異なる二点$x, y \in \mathcal{N}$について$d(x, y) &amp;gt; \varepsilon$であるとき、$\varepsilon$-separatedであるという。また、$T$の部分集合$K \subset T$の$\varepsilon$-separatedの最大の濃度を$K$の（$\varepsilon$-）充填数といい、$\mathcal{P}(K, d, \varepsilon)$と書く。 ステートメントを素直に訳すならば、「互いに$\varepsilon$以上離れるように配置した点の集合」が$\varepsilon$-separatedで、充填数はその最大濃度です。</description></item><item><title>0階/1階最適化アルゴリズムの反復数の下界</title><link>https://neonnnnn.github.io/posts/nesterov-book-lower-bound/</link><pubDate>Mon, 25 Oct 2021 01:56:30 +0900</pubDate><guid>https://neonnnnn.github.io/posts/nesterov-book-lower-bound/</guid><description>はじめに 様々な最適化問題に対して、それを解くための様々な最適化アルゴリズムが提案されています。最適化問題の解きやすさ・最適化アルゴリズムの良し悪しの議論の際に、収束レート、すなわち、$\varepsilon$-近似解を得るために必要な反復数のオーダーというものを考えることがあります（あるいは、結局は同じことですが、反復数に対する精度$\varepsilon$のオーダー）。Nesterov先生の本、Lectures on Convex Optimizationに、0階/1階の最適化アルゴリズムという比較的広いクラスの最適化アルゴリズムの反復数の下界の証明があり、そういえばステートメントは見たことがあったが証明までは見たことがなかったと思い、自分の言葉でややカジュアルに整理してみます（外せる・緩めることのできる仮定などもありますが、とりあえずはそのままで）。
問題設定 問題設定 何らかの連続性を持つ関数$f:\mathbb{R}^n \to \mathbb{R}$に対して、以下の最適化問題を考えます： \begin{align} \min_{x \in C \subseteq \mathbb{R}^n } f(x). \end{align} また、「連続最適化問題を解く」は「$\varepsilon$-近似解（$\varepsilon&amp;gt;0$）を得る」こと、すなわち、$$f(\bar{x}) - f(x^) &amp;lt; \varepsilon, \ \text{where} \ x^ = \underset{x\in C} {\mathrm{argmin}}f(x)$$を満たす$\bar{x} \in C$を得ること、と定義します。この$\bar{x}$を得るための反復数の下界、すなわち、最悪ケースでどの程度の反復数が必要になるのか、ということについて考えます。
考える最適化アルゴリズム 様々な最適化アルゴリズムが存在しますが、その多くは反復法と呼ばれる枠組みに入ります。反復法は、ひどく一般化して書くと、以下のような手順で最適化を行います：
初期解$x_0$と精度$\varepsilon$が与えられる。$k=0$とする。 現在の解$x_k$でオラクルを呼ぶ。オラクルは最適化問題に関する何らかの情報を返す。情報の集合にオラクルから得られた情報を追加する。 情報の集合と、アルゴリズムが定める規則に基づいて、次の解$x_{k+1}$を生成する。 収束条件のチェックをする。$f(x_{k+1}) - f(x^*) &amp;lt; \varepsilon$ならば$\bar{x}:=x_{k+1}$として$\bar{x}$を返す。さもなければ、$k \leftarrow k+1$として、2に戻る。 「オラクルからどのような情報を得るか」「どのように更新するか」が、アルゴリズムの設計において重要になってきます（前者は、設計というよりも問題設定・前提、と言ったほうが正確な気もしますが）。ここでは、以下の二種類のオラクルについて考えます。
0階オラクル：関数の値$f(x_k)$を返す。 1階オラクル：関数の値$f(x_k)$とその勾配$\nabla f(x_k)$を返す。 0階オラクルを用いる場合（しか用いることができない場合）は、いわゆるブラックボックス関数の最適化問題になるかと思います。また、1階オラクルを用いる手法はいわゆる勾配ベースの方法になります。0階オラクルを用いる最適化アルゴリズムを0階の最適化アルゴリズム、1階のオラクルを用いる最適化アルゴリズムを1階の最適化アルゴリズムと呼ぶことにします。
0階の最適化アルゴリズムの場合の下界 最適化問題に対する仮定 実行可能領域として、以下を考えます： \begin{align} B_n = \{x \in \mathbb{R}^n \mid 0 \le x^{(i)} \le 1, i=1,\ldots, n\}.</description></item><item><title>LaTeX Test</title><link>https://neonnnnn.github.io/posts/latex-test/</link><pubDate>Sat, 16 Oct 2021 03:00:00 +0900</pubDate><guid>https://neonnnnn.github.io/posts/latex-test/</guid><description>はじめに Github Pagesを用いて、テックっぽいことや機械学習とその周辺分野に関するアウトプットを行うことにした。 Github Pagesを選んだのは、自由度と手軽さのバランスが良さそうだったからなわけだが、とはいえ自分でゴリゴリCSSやらHTMLやらを書くのは気乗りしない（しセンスもない）ので、Hugoを使って整備をすることにした。 HugoはGo言語で書かれた静的サイトジェネレータで、高速なのが売りっぽい。 テーマも様々提供されていて、どれもこれも質が高い。 パーッと眺めてみて、なんとなくCactusというテーマが気に入りそれを利用することにした。 Github Pages及びHugoの導入自体は非常に簡単で、公式のquick-startとhosting-on-githubに従えば良い。
MathJaxの導入 記事を書くにあたって、数式の記載は避けられない。 このような場合、MathJaxが定番だと思っていたが、ちょっと調べて見た感じだと、どうやらKaTeXというのが最近は良いらしい。 が、CactusでMathJaxが標準でサポートされているので、今回はそのままMathJaxを使うことにする。 速度に不満が出てきたり、Hugoに興味がでた場合にKaTeXへの以降を考えたい。
CactusでのMathJaxの利用は簡単で、front matterにmathjax: trueと記載すれば良い。 以下、簡単なテスト。
inline数式 $で囲めば良い。 $a$, $\boldsymbol{a}$, $\lVert \boldsymbol{x}^\top \rVert^2$ $\sum_{i=1}^N x_i$
別行立て $$で囲めば良い。 $$ \exp (a_i) + \log \left [\frac{b_i}{c_i} + d_i \right] + \lambda $$
alignも使える。改行はバックスラッシュ6つで行う。 \begin{align} \log abc &amp;amp;= \log ab + \log c \\\ &amp;amp;=\log a + \log b + \log c \end{align} 上の数式は以下に対応する。
\begin{align} \log abc &amp;amp;= \log ab + \log c \\\\\\ &amp;amp;=\log a + \log b + \log c \end{align}</description></item><item><title>About me</title><link>https://neonnnnn.github.io/about/</link><pubDate>Thu, 07 Oct 2021 00:00:00 +0900</pubDate><guid>https://neonnnnn.github.io/about/</guid><description>I&amp;rsquo;m Kyohei Atarashi, a software engineer.
Interests Machine Learning Data Mining Human Computation Accounts Github LinkedIn</description></item><item><title>Code Block Test</title><link>https://neonnnnn.github.io/posts/code-block-test/</link><pubDate>Sun, 27 Jun 2021 09:00:00 +0000</pubDate><guid>https://neonnnnn.github.io/posts/code-block-test/</guid><description>String
Using indents:
text text text Fenced code block:
text text &amp;lt;tag&amp;gt; Fenced code block with language (lineNumbersInTable = false):
1// JavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJavaJava 2public final class String 3 implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence 4{ 5 /** The value is used for character storage. */ 6 private final char value[]; 7 8 /** The offset is the first index of the storage that is used. */ 9 private final int offset; 10 11 /** The count is the number of characters in the String.</description></item><item><title>被覆数と充填数の簡単な応用</title><link>https://neonnnnn.github.io/posts/covering-packing-easy-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://neonnnnn.github.io/posts/covering-packing-easy-application/</guid><description>はじめに 前回の記事から悠久の時が経ってしまった……（一週間以内に更新する予定だったのですが、うっかりダンガンロンパに手を出してグダグダになってしまった）。前回の記事ではConvering Number（被覆数）とPacking Number（充填数）を紹介しました。今回の記事では被覆数と充填数の簡単な応用として、
誤り訂正符号（[1]の4.3より） 0階の最適化アルゴリズム ランダムフーリエ特徴[2] の誤差の評価方法を紹介します。
誤り訂正符号の誤差の評価 問題設定・問題意識 舞園さんは長さ$k$の文字列を苗木くんに送りたいです。このとき、攻撃者モノクマによって、送信したメッセージのうち最大で$r$個の文字が書き換えられてしまい、苗木くんは書き換えられたメッセージを受け取ります。例えば、舞園さんは「エスパーですから」という文字列を送るも（$k=8$）、モノクマの悪質なイタズラによって、苗木くんが受け取るメッセージは「アイドルですから」になってしまう、といったものです（$k=4$）。
舞園さんはどのようにすれば正しいメッセージを苗木くんに送ることができるでしょうか？一般的な方法は冗長性をもたせることです。例えば、Majority (logic) Decodingという方法では、舞園さんは元のメッセージを$2r+1$回繰り返したメッセージを送り、苗木くんは繰り返されたメッセージに対して多数決を取ることによって正しい文字列を得ます。上の例にMajority Decodingを適用してみましょう。舞園さんは「エスパーですから」を$2r+1=9$回繰り返した「エスパーですからエスパーですからエスパーですからエスパーですからエスパーですからエスパーですからエスパーですからエスパーですからエスパーですから」という文字列を送ります。そうすると、どのように$r=4$個の文字を変更しようとも、$9$個の（長さ$k=8$の）文字列の中で最も出現頻度が多いのは「エスパーですから」になり、苗木くんは正しいメッセージを受け取ることができます。
Majority Decodingはシンプルでわかりやすいですが、直感的にはなんとも効率が悪そうに思えます。 もっと良い方法はないのでしょうか？
誤り訂正符号と充填数の関係 上の例では日本語の文字列を考えましたが、ここでは0/1の二値の文字列を考えます。まず、誤り訂正符号の定義を以下に示します。
定義4.3.3（誤り訂正符号） ある（固定された）正の整数$k, n, r$が与えられる。２つの写像 \begin{align} E: \{0, 1\}^k \to \{0, 1\}^n \quad \text{and} \quad E: \{0, 1\}^n \to \{0, 1\}^k \end{align} は、任意の$x \in \{0, 1\}^k$と、$E(x)$と最大で$r$個の文字が異なる任意の文字列$y$について、$D(y)=x$が成り立つとき、($r$個の誤りを訂正できる)符号写像、復号写像という。$E$を誤り訂正符号、$E$の像$E(\{0, 1\}^k)$を符号表（codebook）といい、符号表の各要素（すなわち、$E(x)$）を符号語という。 $k, n, r$はそれぞれ「送りたい文字列の長さ」「誤りを考慮して送る文字の長さ」「発生する最大の誤りの数」に対応します。$n$は小さければ小さいほど、効率の良い方法ということになります。前述のMajority decodingでは$n=k(2r+1)$でしたが、これよりも効率の良い方法が存在するのかが気になります。充填数を使うことで、より効率の良い方法が存在することを主張できます。
補題4.3.4 正の数$k, r$に対して、$n$が \begin{align} \log \mathcal{P}(\{0, 1\}^n, d_H, 2r) \ge k \end{align} を満たすとする。このとき、$k$ビットの文字列を$n$ビットの文字列に符号化し、$r$個の誤りを訂正することのできる、誤り訂正符号が存在する。 証明 $\mathcal{N} \subseteq \{0, 1\}^n$を、$n$次元ハミングキューブ$(\{0, 1\}^n, d_H)$のある$2r$-separatedとする。 定義より、$\mathcal{N}$の各要素$x, y \in \mathcal{N}$はハミング距離が$2r$より大きい、すなわち、互いに$2r+1$個以上の文字が異なっている。したがって、$x \in \mathcal{N}$は、最大で$r$個の文字が変わり$x' \in \{0, 1\}^n$になったとしても、$\mathcal{N}$の中で最もハミング距離の近い要素は$x$のままである： \begin{align} x = \underset{y \in \mathcal{N}}{\mathrm{argmin}} \ d_{H}(y, x'), \ \forall x'\in \{0,1\}^n \ \text{s.</description></item></channel></rss>